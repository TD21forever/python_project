### 项目介绍

基于opencv物体检测的贪吃蛇游戏，对着摄像头上下左右移动黄色的物体，控制贪吃蛇移动，ESC退出

### 参考资料

1. [使用OpenCV追踪特定颜色的物体](https://blog.csdn.net/sinat_32582203/article/details/80017259)
2. [Snake](https://github.com/TD21forever/Ly-s_pygame/tree/master/Snake)
3. [图像处理——灰度化、二值化、膨胀算法、腐蚀算法以及开运算和闭运算](http://www.cnblogs.com/gcczhongduan/p/4026934.html)

### 主要思路

1. 追踪特定颜色物体

   1. 预处理

      1. 为什么要高斯模糊

      2. 为什么要二值化处理

      3. 为什么要腐蚀操作

         > 腐蚀是一种消除边界点，使边界向内部收缩的过程。能够用来消除小且无意义的物体。
         >
         > 用3x3的结构元素，扫描图像的每个像素
         >
         > 用结构元素与其覆盖的二值图像做“与”操作
         >
         > 假设都为1，结果图像的该像素为1。否则为0。
         >
         > 结果：使二值图像减小一圈

      4. 为什么要膨胀操作

   2. 找到轮廓和重心

      > 轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同
      > 的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。
      >
      > + 为了更加准确，要使用**二值化**图像。在寻找轮廓之前，要进行阈值化处理
      >   或者 Canny 边界检测。
      > + 查找轮廓的函数会修改原始图像。如果你在找到轮廓之后还想使用原始图
      >   像的话，你应该将原始图像存储到其他变量中。
      > +  在 OpenCV 中，查找轮廓就像在**黑色背景中超白色物体**。你应该记住，
      >   要找的物体应该是白色而背景应该是黑色。 

      1. `findContours`

         + `image, contours, hierarchy = cv.findContours(mask.copy(),cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)`

         + 三个参数
           + 传入图像
           + 轮廓检索模式（**详见文档P122**）
             + **cv2.RETR_EXTERNAL**表示只检测外轮廓
             + **cv2.RETR_LIST**检测的轮廓不建立等级关系
             + **cv2.RETR_CCOMP**建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。
             + **cv2.RETR_TREE**建立一个等级树结构的轮廓。
           + 轮廓近似方法
             + **cv2.CHAIN_APPROX_NONE** 存储所有的边界点
             + **cv2.CHAIN_APPROX_SIMPLE** 存储部分点

         + 返回值

           + 图像

           + 轮廓

             > 轮廓（第二个返回值）是一个 Python
             > 列表，其中存储这图像中的所有轮廓。每一个轮廓都是一个 Numpy 数组，包
             > 含对象边界点（ x， y）的坐标。 

           + 轮廓的层析结构

      2. ` cv.contourArea` 

         + 计算轮廓的面积

      3. `cv.minEnclosingCircle`

         + `(x,y),radius = cv2.minEnclosingCircle(cnt)` 
         + 最小外接圆

      4. `cv.moments`

      5. ` cv.circle`

         + ` cv.circle(frame, (int(x), int(y)), int(radius), (0, 255, 255), 2)`
         + 图片，中心坐标，半径大小，颜色(**BGR**)，边框粗细(-1为填充)

2. 贪吃蛇

3. 如何把两者结合起来（笨办法）

   1. 在移动手上物体的时候，找到的每个重心坐标都记录下来，放到列表里
   2. 取倒数第一个和倒数第五个做差，如果大于一个设定的值，说明手上物体就在朝着某个方向移动

### 其他

1. 用opencv打开摄像头时自动式镜像模式，用`frame = cv.flip(frame,1,dst=None)` 处理下

   *(1水平镜像，0垂直镜像，-1对角镜像）*

2. 可完善的地方

   1. 增加音乐
   2. 难度选择
   3. opencv代码封装
   4. 移动物体控制方向的准确度